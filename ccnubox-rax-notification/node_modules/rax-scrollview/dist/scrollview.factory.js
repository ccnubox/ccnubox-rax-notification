module.exports = function(require, exports, module) {
  with(this) { module.exports = /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = (function(){ var mod;if (!mod) { try { mod = require("rax") } catch(e) {} }return mod;})();

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// https://www.w3.org/TR/html5/webappapis.html#dom-navigator-appcodename
var isWeb = exports.isWeb = (typeof navigator === 'undefined' ? 'undefined' : _typeof(navigator)) === 'object' && (navigator.appCodeName === 'Mozilla' || navigator.product === 'Gecko');
var isNode = exports.isNode = typeof process !== 'undefined' && !!(process.versions && process.versions.node);
var isWeex = exports.isWeex = typeof callNative === 'function';
var isReactNative = exports.isReactNative = typeof __fbBatchedBridgeConfig !== 'undefined';
exports['default'] = module.exports;
exports.default = module.exports;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _rax = __webpack_require__(0);

var _universalEnv = __webpack_require__(1);

var _raxView = __webpack_require__(3);

var _raxView2 = _interopRequireDefault(_raxView);

var _raxRefreshcontrol = __webpack_require__(4);

var _raxRefreshcontrol2 = _interopRequireDefault(_raxRefreshcontrol);

var _timer = __webpack_require__(5);

var _timer2 = _interopRequireDefault(_timer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DEFAULT_END_REACHED_THRESHOLD = 500;
var DEFAULT_SCROLL_CALLBACK_THROTTLE = 50;
var FULL_WIDTH = 750;
var STYLE_NODE_ID = 'rax-scrollview-style';

var ScrollView = function (_Component) {
  _inherits(ScrollView, _Component);

  function ScrollView(props) {
    _classCallCheck(this, ScrollView);

    var _this = _possibleConstructorReturn(this, (ScrollView.__proto__ || Object.getPrototypeOf(ScrollView)).call(this, props));

    _this.lastScrollDistance = 0;
    _this.lastScrollContentSize = 0;
    _this.loadmoreretry = 1;

    _this.handleScroll = function (e) {
      if (_universalEnv.isWeb) {
        if (_this.props.onScroll) {
          e.nativeEvent = {
            get contentOffset() {
              return {
                x: e.target.scrollLeft,
                y: e.target.scrollTop
              };
            }
          };
          _this.props.onScroll(e);
        }

        if (_this.props.onEndReached) {
          if (!_this.scrollerNode) {
            _this.scrollerNode = (0, _rax.findDOMNode)(_this.refs.scroller);
            _this.scrollerContentNode = (0, _rax.findDOMNode)(_this.refs.contentContainer);

            _this.scrollerNodeSize = _this.props.horizontal ? _this.scrollerNode.offsetWidth : _this.scrollerNode.offsetHeight;
          }

          // NOTE：in iOS7/8 offsetHeight/Width is is inaccurate （ use scrollHeight/Width ）
          var scrollContentSize = _this.props.horizontal ? _this.scrollerNode.scrollWidth : _this.scrollerNode.scrollHeight;
          var scrollDistance = _this.props.horizontal ? _this.scrollerNode.scrollLeft : _this.scrollerNode.scrollTop;
          var isEndReached = scrollContentSize - scrollDistance - _this.scrollerNodeSize < _this.props.onEndReachedThreshold;

          var isScrollToEnd = scrollDistance > _this.lastScrollDistance;
          var isLoadedMoreContent = scrollContentSize != _this.lastScrollContentSize;

          if (isEndReached && isScrollToEnd && isLoadedMoreContent) {
            _this.lastScrollContentSize = scrollContentSize;
            _this.props.onEndReached(e);
          }

          _this.lastScrollDistance = scrollDistance;
        }
      }
      if (_universalEnv.isWeex) {
        e.nativeEvent = {
          contentOffset: {
            // HACK: weex scroll event value is opposite of web
            x: -e.contentOffset.x,
            y: -e.contentOffset.y
          }
        };
        _this.props.onScroll(e);
      }
    };

    _this.resetScroll = function () {
      if (_universalEnv.isWeb) {
        _this.lastScrollContentSize = 0;
        _this.lastScrollDistance = 0;
      } else {
        _this.setState({
          loadmoreretry: _this.loadmoreretry++
        });
      }
    };

    _this.scrollTo = function (options) {
      var x = parseInt(options.x);
      var y = parseInt(options.y);
      var animated = options && typeof options.animated !== 'undefined' ? options.animated : true;

      if (_universalEnv.isWeex) {
        var dom = __weex_require__('@weex-module/dom');
        var contentContainer = (0, _rax.findDOMNode)(_this.refs.contentContainer);
        dom.scrollToElement(contentContainer.ref, {
          offset: x || y || 0,
          animated: animated
        });
      } else {
        var pixelRatio = document.documentElement.clientWidth / FULL_WIDTH;
        var scrollView = (0, _rax.findDOMNode)(_this.refs.scroller);
        var scrollLeft = scrollView.scrollLeft;
        var scrollTop = scrollView.scrollTop;

        if (animated) {
          var timer = new _timer2.default({
            duration: 400,
            easing: 'easeOutSine',
            onRun: function onRun(e) {
              if (x >= 0) {
                scrollView.scrollLeft = scrollLeft + e.percent * (x * pixelRatio - scrollLeft);
              }
              if (y >= 0) {
                scrollView.scrollTop = scrollTop + e.percent * (y * pixelRatio - scrollTop);
              }
            }
          });
          timer.run();
        } else {
          if (x >= 0) {
            (0, _rax.findDOMNode)(_this.refs.scroller).scrollLeft = pixelRatio * x;
          }

          if (y >= 0) {
            (0, _rax.findDOMNode)(_this.refs.scroller).scrollTop = pixelRatio * y;
          }
        }
      }
    };

    _this.state = {
      loadmoreretry: 0
    };
    return _this;
  }

  _createClass(ScrollView, [{
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          id = _props.id,
          style = _props.style,
          scrollEventThrottle = _props.scrollEventThrottle,
          showsHorizontalScrollIndicator = _props.showsHorizontalScrollIndicator,
          showsVerticalScrollIndicator = _props.showsVerticalScrollIndicator,
          onEndReached = _props.onEndReached,
          onEndReachedThreshold = _props.onEndReachedThreshold,
          onScroll = _props.onScroll,
          children = _props.children;

      // In weex must be int value

      onEndReachedThreshold = parseInt(onEndReachedThreshold, 10);

      var contentContainerStyle = [this.props.horizontal && styles.contentContainerHorizontal, this.props.contentContainerStyle];

      // bugfix: fix scrollview flex in ios 78
      if (!_universalEnv.isWeex && !this.props.horizontal) {
        contentContainerStyle.push(styles.containerWebStyle);
      }

      if (this.props.style) {
        var childLayoutProps = ['alignItems', 'justifyContent'].filter(function (prop) {
          return _this2.props.style[prop] !== undefined;
        });

        if (childLayoutProps.length !== 0) {
          console.warn('ScrollView child layout (' + JSON.stringify(childLayoutProps) + ') must be applied through the contentContainerStyle prop.');
        }
      }

      var refreshContainer = (0, _rax.createElement)(_raxView2.default, null),
          contentChild = void 0;
      if (Array.isArray(children)) {
        contentChild = children.map(function (child, index) {
          if (child && child.type == _raxRefreshcontrol2.default) {
            refreshContainer = child;
          } else {
            return child;
          }
        });
      } else {
        contentChild = children;
      }

      var contentContainer = (0, _rax.createElement)(
        _raxView2.default,
        {
          ref: 'contentContainer',
          style: contentContainerStyle },
        contentChild
      );

      var baseStyle = this.props.horizontal ? styles.baseHorizontal : styles.baseVertical;

      var scrollerStyle = _extends({}, baseStyle, this.props.style);

      var showsScrollIndicator = this.props.horizontal ? showsHorizontalScrollIndicator : showsVerticalScrollIndicator;

      if (_universalEnv.isWeex) {
        return (0, _rax.createElement)(
          'scroller',
          _extends({}, this.props, {
            style: scrollerStyle,
            showScrollbar: showsScrollIndicator,
            onLoadmore: onEndReached,
            onScroll: onScroll ? this.handleScroll : null,
            loadmoreoffset: onEndReachedThreshold,
            loadmoreretry: this.state.loadmoreretry,
            scrollDirection: this.props.horizontal ? 'horizontal' : 'vertical'
          }),
          refreshContainer,
          contentContainer
        );
      } else {
        var handleScroll = this.handleScroll;
        if (scrollEventThrottle) {
          handleScroll = throttle(handleScroll, scrollEventThrottle);
        }
        if (!showsScrollIndicator && typeof document !== 'undefined' && !document.getElementById(STYLE_NODE_ID)) {
          var styleNode = document.createElement('style');
          styleNode.id = STYLE_NODE_ID;
          document.head.appendChild(styleNode);
          styleNode.innerHTML = '.' + this.props.className + '::-webkit-scrollbar{display: none;}';
        }

        scrollerStyle.webkitOverflowScrolling = 'touch';
        scrollerStyle.overflow = 'scroll';

        var webProps = _extends({}, this.props, {
          ref: 'scroller',
          style: scrollerStyle,
          onScroll: handleScroll
        });
        delete webProps.onEndReachedThreshold;

        return (0, _rax.createElement)(
          _raxView2.default,
          webProps,
          contentContainer
        );
      }
    }
  }]);

  return ScrollView;
}(_rax.Component);

ScrollView.propTypes = {};
ScrollView.defaultProps = {
  scrollEventThrottle: DEFAULT_SCROLL_CALLBACK_THROTTLE,
  onEndReachedThreshold: DEFAULT_END_REACHED_THRESHOLD,
  showsHorizontalScrollIndicator: true,
  showsVerticalScrollIndicator: true,
  className: 'rax-scrollview'
};


function throttle(func, wait) {
  var ctx, args, rtn, timeoutID;
  var last = 0;

  function call() {
    timeoutID = 0;
    last = +new Date();
    rtn = func.apply(ctx, args);
    ctx = null;
    args = null;
  }

  return function throttled() {
    ctx = this;
    args = arguments;
    var delta = new Date() - last;
    if (!timeoutID) if (delta >= wait) call();else timeoutID = setTimeout(call, wait - delta);
    return rtn;
  };
}

var styles = {
  baseVertical: {
    flex: 1,
    flexDirection: 'column'
  },
  baseHorizontal: {
    flex: 1,
    flexDirection: 'row'
  },
  contentContainerHorizontal: {
    flexDirection: 'row'
  },
  containerWebStyle: {
    display: 'block'
  }
};

exports.default = ScrollView;
module.exports = exports['default'];

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _rax = __webpack_require__(0);

var _universalEnv = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var View = function (_Component) {
  _inherits(View, _Component);

  function View() {
    _classCallCheck(this, View);

    return _possibleConstructorReturn(this, (View.__proto__ || Object.getPrototypeOf(View)).apply(this, arguments));
  }

  _createClass(View, [{
    key: 'render',
    value: function render() {
      var props = this.props;
      if (_universalEnv.isWeex) {
        // TODO: do not pass object value in props
        return (0, _rax.createElement)('div', props);
      } else {
        var styleProps = _extends({}, styles.initial, props.style);
        return (0, _rax.createElement)('div', _extends({}, props, { style: styleProps }));
      }
    }
  }]);

  return View;
}(_rax.Component);

View.propTypes = {};


var styles = {
  initial: {
    border: '0 solid black',
    position: 'relative',
    boxSizing: 'border-box',
    display: 'flex',
    flexDirection: 'column',
    alignContent: 'flex-start',
    flexShrink: 0
  }
};

exports.default = View;
module.exports = exports['default'];

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _rax = __webpack_require__(0);

var _universalEnv = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RefreshControl = function (_Component) {
  _inherits(RefreshControl, _Component);

  function RefreshControl() {
    _classCallCheck(this, RefreshControl);

    return _possibleConstructorReturn(this, (RefreshControl.__proto__ || Object.getPrototypeOf(RefreshControl)).apply(this, arguments));
  }

  _createClass(RefreshControl, [{
    key: 'render',
    value: function render() {
      if (_universalEnv.isWeex) {
        var displayRefresh = this.props.refreshing ? 'show' : 'hide';
        return (0, _rax.createElement)(
          'refresh',
          _extends({}, this.props, { display: displayRefresh }),
          this.props.children
        );
      } else {
        return null;
      }
    }
  }]);

  return RefreshControl;
}(_rax.Component);

exports.default = RefreshControl;
module.exports = exports['default'];

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var requestAnimationFrame = typeof requestAnimationFrame === 'undefined' ? typeof webkitRequestAnimationFrame === 'undefined' ? function (job) {
  return setTimeout(job, 16);
} : webkitRequestAnimationFrame : requestAnimationFrame;

var cancelAnimationFrame = typeof cancelAnimationFrame === 'undefined' ? typeof webkitCancelAnimationFrame === 'undefined' ? clearTimeout : webkitCancelAnimationFrame : cancelAnimationFrame;

var TYPES = {
  START: 'start',
  END: 'end',
  RUN: 'run',
  STOP: 'stop'
};

var easing = {
  easeOutSine: function easeOutSine(x) {
    return Math.sin(x * Math.PI / 2);
  }
};

var MIN_DURATION = 1;

var noop = function noop() {};

var Timer = function () {
  function Timer(config) {
    _classCallCheck(this, Timer);

    this.config = _extends({
      easing: 'linear',
      duration: Infinity,
      onStart: noop,
      onRun: noop,
      onStop: noop,
      onEnd: noop
    }, config);
  }

  _createClass(Timer, [{
    key: 'run',
    value: function run() {
      var _config = this.config,
          duration = _config.duration,
          onStart = _config.onStart,
          onRun = _config.onRun;

      if (duration <= MIN_DURATION) {
        this.isfinished = true;
        onRun({ percent: 1 });
        this.stop();
      }
      if (this.isfinished) return;
      this._hasFinishedPercent = this._stop && this._stop.percent || 0;
      this._stop = null;
      this.start = Date.now();
      this.percent = 0;
      onStart({ percent: 0, type: TYPES.START });
      // epsilon determines the precision of the solved values
      var epsilon = 1000 / 60 / duration / 4;
      this.easingFn = easing[this.config.easing];
      this._run();
    }
  }, {
    key: '_run',
    value: function _run() {
      var _this = this;

      var _config2 = this.config,
          onRun = _config2.onRun,
          onStop = _config2.onStop;

      this._raf && cancelAnimationFrame(this._raf);
      this._raf = requestAnimationFrame(function () {
        _this.now = Date.now();
        _this.t = _this.now - _this.start;
        _this.duration = _this.now - _this.start >= _this.config.duration ? _this.config.duration : _this.now - _this.start;
        _this.progress = _this.easingFn(_this.duration / _this.config.duration);
        _this.percent = _this.duration / _this.config.duration + _this._hasFinishedPercent;
        if (_this.percent >= 1 || _this._stop) {
          _this.percent = _this._stop && _this._stop.percent ? _this._stop.percent : 1;
          _this.duration = _this._stop && _this._stop.duration ? _this._stop.duration : _this.duration;

          onRun({
            percent: _this.progress,
            originPercent: _this.percent,
            t: _this.t,
            type: TYPES.RUN
          });

          onStop({
            percent: _this.percent,
            t: _this.t,
            type: TYPES.STOP
          });

          if (_this.percent >= 1) {
            _this.isfinished = true;
            _this.stop();
          }
          return;
        }

        onRun({
          percent: _this.progress,
          originPercent: _this.percent,
          t: _this.t,
          type: TYPES.RUN
        });

        _this._run();
      });
    }
  }, {
    key: 'stop',
    value: function stop() {
      var onEnd = this.config.onEnd;

      this._stop = {
        percent: this.percent,
        now: this.now
      };
      onEnd({
        percent: 1,
        t: this.t,
        type: TYPES.END
      });
      cancelAnimationFrame(this._raf);
    }
  }]);

  return Timer;
}();

exports.default = Timer;
module.exports = exports['default'];

/***/ })
/******/ ])}};;
//# sourceMappingURL=scrollview.factory.map